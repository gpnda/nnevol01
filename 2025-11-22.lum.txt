2025-11-22.lum.txt
	Dropbox чтото не синхронизируется.
	Пока можно двигаться в том направлении которое помню.
	!!ОТБОР!!
	Я сделал существ смертными.
	Я дал им возможность кусать пищу и жить дольше.
	какие варианты что можно делать?
		1. Пища чтобы покусанная сильно пища - исчезала
		2. Контроль количества пищи в мире
		3. Размножение существ в мире.
			Как я делал в предыдущей версии приложения? Я делал, чтобы существо дожившее до определенного возраста - давало потомство. Далее - было еще две отсечки, когда существо могло доть потомство еще и еще раз.
		4. Можно делать интерфейс окна - гдето дать возможность посмотреть как менялась энергия существа за его жизнь: "Пила энергии". 
			Я сейчас думаю, что интеллект может мне с интерфейсом помочь мощно.
			Я могу попросить его текущий рендерер обернуть в метод и спрятать на отдельную pygame.surface. Тогда я мог бы добавить к интерфейсу виджет, который выскакивает поверх карты, такое popup окно, содержащее информацию о существе, в частности - его пилу энергии. Также можно попросить добавить возможность выбирать существо мышкой. И тогда у выбранного существа выводится дополнительная информация: Возрас, энергия, кусание, и т.д. 


2025-11-23
	переделал приложение на работу с numpy картой.
	запустил, вроде работает.

	Засунул эту новую функцию в тестовые стенды raycast - попытался стенд адаптировать, но что-то он выдает неверные результаты
	массив видения теперь содержит какие странные результаты, серые пикселы 
	ну и вообще видение не соответствует тому, что существо должно видеть.

	Дело в стенде, или дело в функции?
		+++
		Дело было просто в замене цветов - в тестовом стенде цвета были занначены другие, поэтому и видение было неверное. Вроде поправил, вообще стенд для тестирования raycast я оставил один, чтоб не путаться и не попадать на внесение поправок в двух почти одинаковых файлах.


	--------------

	Так чтобы сразу внедрить условия для предотвращения перенаселенности мира и вымирания мира, нужно: 
	+ 1. Перед тем, как вызвать убирание всех мертвых существ - поставить условие: если существ менее 50, то всем существам задать энергию = 1.0
	+ 2. Перед циклом размножения - поставить условие: если существ более 950, то не выполнять цикл размножения
	3. Где-то поставить проверку: если популяция не в промежутке 200 - 800, то выставить флаг stop_mutation = True
	4. В месте, где существа мутируют - читать конфиг, выставлен ли флаг stop_mutation, если да, то веса не мутируют

	--------------

	Далее - надо будет делать волны изобилия пищи, я писал об этом тут: "2024-11-10.lum.txt"
	Когда волны появятся - можно будет сдвигать фазы этой синусоиды, чтобы выставлять соответственно регулятор вверх или вниз. К изолильному иру, или к скудному миру, на дистации 60 поколений.

	--------------

	И надо делать механизм мутирования весов, соственно чтобы начался естественный отбор.

	--------------

	И вот уже далее - надо заняться оптимизацией, ускорением, и интерфейсом для наблюдения за процессом эволюции.

	--------------

	Далее - можно подумать как сделать интерфейс для инспектирования существа и эксперимент с конусом.


==================
мысли в разнобой:
1. надо проверить, что массивы в debug не создают утечку памяти, они должны обнуляться при каждом тике.
2. надо проверить что механизмы регуляции популяции работаю верно

Приложение ведет себя странно - я проставил рандомные возрасты существам. По идее при пересечении границы популяции 99 существа - они не должны сразу все дружно рожать.
Однако я наблюдал только что, как только, при пересечении этой границы 35 существ сразу начали рожать. Ну немного странно что из 98 существ 35 начали рожать, и общая популяция стала равно 185.


	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	POPULATION: 101
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	POPULATION: 98
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	начало цикла по рождению детей
	POPULATION: 185
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существа.
	Существу повезло, оно укусило пищу. Увеличить энергию существ


Кажется чтото не так с условием:
	for i in filter(lambda c:c.age in [100,200,300,500], self.creatures):

	По моей задумке оно должно перебирать (по одному разу) существа, у которых текущий возраст равен либо 100, либо 200, либо 300, либо 500...
	Кажется оно чтото не то делает

Да нет, вроде тут все чисто.
Другая мысль - про волны размножения.
типа сначала 4 существа дали по 3 потомка, теперь уже 12 существ имеют синхронный возраст, и в какойто момент эти 12 существ дадут уже 36 потомков так?
Это появляется такой "золотой такт" когда он достигнет любой отсечки, на свет появится уже 36*3 существ.
Так что пока у меня мысль такая: надо существам каждому выдавать заранее случайный массив репродукции.
И добавить функцию ,которая бы возвращала true. в моменты когда c.age присутствует в списке c.birth_ages [random.randint(90, 110), random.randint(190, 210), random.randint(290, 310)]
Это должно решить проблему "золотого такта".

Видимо и в прошлой реализации у меня была такаяже ситуация с контролем размера популяции. Год назад.

Если действительно поможет - это будет любопытно. Вообще неожиданная, неинтуитивная хрень.



2025-11-25

	Я планировал двигаться по этой траектории:
		
		3. Где-то поставить проверку: если популяция не в промежутке 200 - 800, то выставить флаг stop_mutation = True
		4. В месте, где существа мутируют - читать конфиг, выставлен ли флаг stop_mutation, если да, то веса не мутируют

		--------------

		Далее - надо будет делать волны изобилия пищи, я писал об этом тут: "2024-11-10.lum.txt"
		Когда волны появятся - можно будет сдвигать фазы этой синусоиды, чтобы выставлять соответственно регулятор вверх или вниз. К изолильному иру, или к скудному миру, на дистации 60 поколений.

		--------------

		И надо делать механизм мутирования весов, соственно чтобы начался естественный отбор.

		--------------

		И вот уже далее - надо заняться оптимизацией, ускорением, и интерфейсом для наблюдения за процессом эволюции.

		--------------

		Далее - можно подумать как сделать интерфейс для инспектирования существа и эксперимент с конусом.

	Но это было пару дней назад.
	Я в тот день столкнулся с проблемой что механизмы контроля размера популяции работают странно. И через пару дней я вяснил почему - 
	причина в том, что если у существ жестко прописанные даты для размножения, они одинаковые у потомков тоже,
	то рано или поздно возникает эффект взрывного роста популяций - в какойто момент существа синхронизируются и 
	дают потомство в огромном количестве, превыщающем лимит в столько раз, сколько потомков у нас есть. 
	То есть они там почемуто практически все синхронизируются.
	Эффект устраняется ,если дать нгебольшой разброс в датах, я дал окно 290..310.
	И это сразу сгладило ситуацию, взрывов популяций больше не наблюдается.

	Затем я нашел видео про Numba JIT и попытался эту историю внедрить в функцию расчета всех сетей.
	Ну красава, что я вообще додумался что лучше объединить расчеты всех сеток и расчеты всех raycast.
	Но загвоздка в том, что у меня эти функции оперируют именно штатными списками Python.
	А Numba хочет "векторизованные данные"

	Теперь у меня возникает еще два дополнительных вектора куда развивать код:
	1. Переделать 2 быстрые функции под векторизацию
	2. Вцелом переделывать приложение, чтобы списки использовались только там, где это неважно.
	   Вернее так, чтобы карта мира была numpy матрицей, видение - тоже внутри чтобы работлао на numpy массивах.
	   

	

2025-11-28
У меня имеется нейронная сеть, 45 входов, первый слой с 50 нейронами, второй слой с 10 нейронами, выходной слой с 3 нейронами
У меня есть задача передавать значения весов в быструю функцию на Numba JIT. То есть желательно, чтобы эти веса были переданы в каком-то относительно простом плоском массиве.
Я подумал, что все веса можно просто в порядке следования записать в одномерный вектор вещественных чисел. А дополнительно к весам передавать структуру сети. Например информацию о том, что с 0 по 45 элемент - это веса самого первого нейрона в первом слое, с 45 по 90 - это веса второго нейроно в первом слое, ... с 2250 по 2350 - это веса первого нейрона второго слоя, и так далее.
Покритикуй жестко эту идею, хочу проверить ее на прочность.

Идея не очень, видимо:
	3. Ужасная производительность при обращении
	В Numba важна не только компактность данных, но и паттерн доступа к памяти. Ваша схема требует сложных вычислений индексов для каждого обращения:
	python
	# Вместо простого:
	layer1_weights[i][j]
	# Вы получаете:
	weight = flat_weights[layer1_start + i * input_size + j]










# Представьте, если бы все веса были в одной большой матрице:
# all_weights shape: [n_creatures, total_weights]

# Тогда можно было бы сделать так:
def fully_vectorized_forward(all_visions, all_weights):
    # Вся обработка для всех существ одновременно
    # БЕЗ циклов for
    layer1_output = sigmoid(np.dot(all_visions, all_weights_layer1))
    layer2_output = sigmoid(np.dot(layer1_output, all_weights_layer2))
    # ...
    return all_outputs  # [n_creatures, N_OUTPUTS]





2025-11-26
	Сейчас методом проб обнаружил, что Nubma не всегда съедает операции на 2D массивами типа append
	@jit(nopython=True)
	def bad_example_append():
	    arr=[]
	    arr.append([1,2])
	    arr.append([1,2])
	    arr.append([1,2])
	    nparr = np.array(arr)
	    print(f"Сконвертируем в np.array: {nparr.shape}")
	    new_nparr = np.append(nparr, [[3,3]], axis=0)  # Раскомментируйте для ошибки
	    return new_nparr

	Эта функция выдает ошибку. Именно потому что меняется размер 2D массива.
	ИИ рекомендует создать zerofill массив с заведомо большого размера и просто заполнять его данными.

	Вот так - нормально, работает:
	---------------------------------
	@jit(nopython=True)
	def bad_example_append():
	    arr=[]
	    arr.append([1,2])
	    arr.append([1,2])
	    arr.append([1,2])

	    nparr = np.zeros((4, 2)) # Сразу создаем zerofill массив
	    nparr[:3] = np.array(arr)
	    print(f"Сконвертировали в np.array: {nparr.shape}")

	    # Просто заполняем массив другими значениями (вместо нулей)
	    nparr[3] = [3, 3]
	    return nparr
	---------------------------------


	Еще заметил, что Numba в принципе не любит пустые массивы.
	

	Вообще, наверное JIT Numba нормально работает с функциями, внутри которых все расчитывается на списках, а перед выдачей результата - обратно переводится в numpy массив.
	Но давай просто перепишу быструю функцию полностью на numpy, как будет в python вообще не существует списков.





gEnergy_per_tick
gM_probability
gM_strength
gMax_age
gBirth_ages
gN_children
gFood_bonus
gEnergy_for_move
gEnergy_for_rotation
gEnergy_for_bite
gFood_amount  ???
gFood_volume
gFood_piece_size
gFood_bonus_for_bite_creature
gFood_penalty_for_bite_creature
gCollision_penalty


Чем я решил не управлять
gMax_energy - пусть всегда будет 1.0, так проще думать о модели питания и затрат энергии. Да и графики рисовтаь проще.
gNetConfiguration - по новой идее - это будет для симуляции неизвестно - это все отдается на откуп 
                    быстрой функции calc, вернее классу NeuralNetwork который в данный момент подключен.

Стырые имена переменных сохранятьне буду. Мне кажется можно назвать удачнее и понятнее.
А спрошу у дипсика.
Пока писал запрос дипсику, вдруг понял что у меня возможно две переменные, с одним назначением. Нет?
gFood_bonus 
И
gFood_piece_size 
Это надо бы проверить в коде старого приложения.
...
Да, в старом приложении переменная gFood_piece_size вообще в симуляции не участвует.
Еще заменил, что я в старом приложении всетаки второпях там и сям видимо использовал магические числа вместо этих переменных.
Почему так? Специально создать переменную, а потом ее не использовать.
Эм.. наверное потому что я эти переменные внедрял пачкой, лучше было бы внедрять их по одной, вдумчиво.



С помощью дипсика подобрал удачные как мне кажется имена переменным.

	Мутации
		sim_mutation_probability		gM_probability								вероятность мутации
		sim_mutation_strength			gM_strength									сила мутации

	Общие настройки мира:
		sim_creature_max_age			gMax_age									максимальный возраст = 5000 потом умирает от старости
		sim_food_amount					gFood_amount								количество кусков пищи на карте
		sim_food_energy_capacity		gFood_volume								объем энергии, заключенный в одной пище
		sim_food_energy_chunk			gFood_piece_size							объем энергии, отнимаемый от общего объема пищи в момент укуса (на сколько уменьшается объем доступной пищи).

	Жизненный цикл и размножение:
		sim_reproduction_ages			gBirth_ages									[] список возрастов, когда происходит размножение существа, рождение детей
		sim_reproduction_offsprings		gN_children									количество детей которые рождаются в каждые роды

	Затраты энергии на действия:
		sim_energy_cost_tick			gEnergy_per_tick							сколько энергии тратит существо просто за существование в мире 1 рабочий такт
		sim_energy_cost_move			gEnergy_for_move							сколько энергии тратит существо когда движется с максимальной скоростью
		sim_energy_cost_rotate			gEnergy_for_rotation						сколько энергии тратит существо когда поворачиватся на максимальный угол, то есть с максимальным усилием
		sim_energy_cost_bite			gEnergy_for_bite							сколько энергии тратит существо на усилие укусить
		sim_energy_gain_from_food		gFood_bonus									бонус к энергии, который получает существо когда кусает пищу
		sim_energy_gain_from_bite_cr	gFood_bonus_for_bite_creature				Насколько увеличитс яэнергия существа когда оно укусит другое существо
		sim_energy_loss_bitten			gFood_penalty_for_bite_creature				на сколько уменьшится энергия у существа которое ктото укусил
		sim_energy_loss_collision		gCollision_penalty							урон рпи столкновении со стенкой ну или просто от любого столкновения



Возможно будет прикольно сделать gFood_bonus === gFood_piece_size
тождественными.
Тогда наверное будет более интуитивно понятна связь между 
количеством кусаний / энергией получаемой от пищи / и объемом пищи
вообще странно что я до этого не додумался тогда.. видимо уже нетерпелось запустить симуляцию.
А ведь это так интуитивно и естественно.
Это как будто шаг к герметичному миру, но пока хех, не знаю зачем мне герметичность.
Но.. хм.. что будет если я захочу сделать огромные куски пищи, незаканчивающиеся.

ООооооо!!! Эксперимен Съедобная стенаааааа
Как будет организована жизнь, если сделать такую съедобную стенку?
А если с глубиной зрения??? Круто же будет посмотреть как они будут жить.

Да, эту историю нельзя симулировать, если нет управления Объемом  gFood_volume.
Вернее можно, есть способ да. Можно генерировать пищу вдоль этой стенки, взамен съеденой пищи - будет появляться новая.
Это как будто тогда не требует отдельного управления gFood_volume.

Зачем мне герметичность мира? Не нужна.
Тогда пусть я буду иметь чуть больше свободы для симуляции, чем непонятно зачем стремиться к герметичному миру.






